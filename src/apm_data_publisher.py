
import rospy
from dronekit import connect
import time
import numpy as np
import json
import subprocess
import os
import argparse
from datetime import datetime
from std_msgs.msg import String

parser = argparse.ArgumentParser(description='Ardupilot data publisher node')
parser.add_argument('--console_port',
				help="This is a second port generated by socat.sh")
parser.add_argument('--udp',
				help="IP of Cubepilot with port, e.i. localhost:14550, 192.168.8.126:14550")
parser.add_argument('--serial',
				help="a serial port of Cubepilot, /dev/ttyUSB0:921600")

args = parser.parse_args(rospy.myargv()[1:])
CONSOLE_PORT = args.console_port
UDP = args.udp
UART = args.serial

if CONSOLE_PORT is None:
	print("Error: please specify second port of socat generated")
	quit()

if UART is not None:
	connection_str = UART.split(":")

if UDP is not None:
	connection_str = UDP.split(":")


###############################################
################# Init/Declare ################
###############################################


rospy.init_node("webrtc_telemetry_node", anonymous=True)

if connection_str[0].startswith('/dev/'):
	device = connection_str[0]
	baudrate = int(connection_str[1])
	vehicle = connect(device, baud=baudrate)
else:
	vehicle = connect(connection_str[0]+":"+connection_str[1])

roll = 0.0
pitch = 0.0
yaw = 0.0
lat = 0.0
lon = 0.0
fix_type = 0
alt_rel = 0.0
alt = 0.0
home_alt = 0.0
airspeed = 0.0
groundspeed = 0.0
mode = "HOLD"
nextwp = 0
travelled = 0.0
tohome = 0.0
home_lat = 0.0
home_lon = 0.0
prev_lat = 0.0
prev_lon = 0.0
volt = 0.0

wp_speed = 10.0

telem_dict = {
				"TELEMETRY": {
						"POS": {
								"LAT": lat, "LON": lon, "ALT": alt_rel},
						"ATT": {
								"ROLL": roll, "PITCH": pitch, "YAW": yaw},
						"DIST": {"TRAVELLED": travelled, "TOHOME": tohome},
						"SPEED": {"AIR": airspeed, "GROUND": groundspeed},
						"MODE": "MAN",
						"GPS": "",
						"BATT": {"VOLT": volt}
						}	
			}

proj_path = os.getcwd()
file_path = os.path.join(proj_path, "console_telemetry.txt")

############################################
################# Functions ################
############################################
def mission_callback(msg):
	print(msg.data)

def get_distance(lat1, lon1, lat2, lon2):

	R = 6371.0*1000.0
	lat_start = np.radians(lat1)
	lon_start = np.radians(lon1)
	lat_end = np.radians(lat2)
	lon_end = np.radians(lon2)
	dLat = lat_end - lat_start
	dLon = lon_end - lon_start

	a = np.sin(dLat/2.0)*np.sin(dLat/2.0) + np.cos(lat_start)*np.cos(lat_end)*np.sin(dLon/2.0)*np.sin(dLon/2.0)
	c = 2.0*np.arctan2(np.sqrt(a),np.sqrt(1-a))

	d = c*R

	return d

# Callback to print the location in global frame
def location_callback(self, attr_name, value):
	global lat, lon, alt_rel, telem_dict, prev_lat, prev_lon, travelled
	# global cur_lat, cur_lon
	lat = value.global_frame.lat
	lon = value.global_frame.lon

	alt_rel = value.global_relative_frame.alt

	telem_dict["TELEMETRY"]["POS"]["LAT"] = lat
	telem_dict["TELEMETRY"]["POS"]["LON"] = lon
	telem_dict["TELEMETRY"]["POS"]["ALT"] = round(alt_rel,2)

	_mode = telem_dict["TELEMETRY"]["MODE"]

	if (lat != 0.0) and (lon != 0.0) and (prev_lat != 0.0) and (prev_lon != 0.0) and ((_mode == "AUTO") or (_mode == "GUIDED")):
		travelled += get_distance(prev_lat, prev_lon, lat, lon)
		telem_dict["TELEMETRY"]["DIST"]["TRAVELLED"] = round(travelled, 2)

	prev_lat = lat
	prev_lon = lon
		
def attitude_callback(self, attr_name, value):
	global roll, pitch, yaw, telem_dict
	# global cur_yaw
	roll = np.degrees(value.roll)
	pitch = np.degrees(value.pitch)
	yaw = np.degrees(value.yaw)

	telem_dict["TELEMETRY"]["ATT"]["ROLL"] = round(roll,2)
	telem_dict["TELEMETRY"]["ATT"]["PITCH"] = round(pitch,2)
	telem_dict["TELEMETRY"]["ATT"]["YAW"] = round(yaw,2)

def gps_callback(self, attr_name, value):
	global fix_type, telem_dict
	# global gps_status
	fix_type = value.fix_type

	# 3 = 3DFix
	# 4 = 3DGPS
	# 5 = rtkFloat
	# 6 = rtkFixed
	## range is -pi to pi, 0 is north
	if fix_type < 3:
		telem_dict["TELEMETRY"]["GPS"]= ""
	elif fix_type == 3:
		telem_dict["TELEMETRY"]["GPS"]= "3D"
	elif fix_type == 4:
		telem_dict["TELEMETRY"]["GPS"]= "DGPS"
	elif fix_type == 5:
		telem_dict["TELEMETRY"]["GPS"]= "RTKFLT"
	elif fix_type == 6:
		telem_dict["TELEMETRY"]["GPS"]= "RTKFXD"

def groundspeed_callback(self, attr_name, value):
	global groundspeed, telem_dict
	groundspeed = value
	telem_dict["TELEMETRY"]["SPEED"]["GROUND"] = round(groundspeed,2)

def airspeed_callback(self, attr_name, value):
	global airspeed, telem_dict
	airspeed = value
	telem_dict["TELEMETRY"]["SPEED"]["AIR"] = round(airspeed,2)

def mode_callback(self, attr_name, value):
	global mode, telem_dict
	mode = value.name
	if (mode == "MANUAL") or (mode == "STABILIZE") or (mode == "ALT_HOLD") or (mode == "ACRO"):
		telem_dict["TELEMETRY"]["MODE"] = "MAN"
	elif (mode == "AUTO") or (mode == "LOITER") or (mode == "GUIDED") or (mode == "RTL") or (mode == "LAND"):
		telem_dict["TELEMETRY"]["MODE"] = "AUTO"

def batt_callback(self, attr_name, value):
	global volt, telem_dict
	volt = value.voltage
	telem_dict["TELEMETRY"]["BATT"]["VOLT"] = round(volt,2)

def wpnav_speed_callback(self, attr_name, value):
	global wp_speed

	wp_speed = value
	print("got wp_speed", wp_speed)

# def nextwp_callback(self, attr_name, value):
# 	global nextwp, telem_dict

# 	nextwp = value.next
# 	print("nextwp", nextwp)

def getMission():

	global cmds

	cmds.download()
	cmds.wait_ready()

	total_wps = vehicle.commands.count

	lat_list = np.array([])
	lon_list = np.array([])
	alt_list = np.array([])

	for i in range(total_wps):
		wp = vehicle.commands[i]
		lat_list = np.append(lat_list, wp.x)
		lon_list = np.append(lon_list, wp.y)
		alt_list = np.append(alt_list, wp.z)


	print("total_wps: ", total_wps)

	print("LAT", lat_list)
	print("LON", lon_list)

	return lat_list, lon_list, total_wps

def calculate_ETA(nextwp, cur_lat, cur_lon):

	global target_lat_list, target_lon_list, total_points
	global groundspeed, wp_speed

	ETA_list = []
	linuxTime_list = []

	## nextwp in Ardupilot never be 0, always start from 1
	for i in range(total_points):

		################################
		## Points that already passed ##
		################################
		if i < (nextwp-1):

			ETA_passed = "Passed"
			ETA_list.append(ETA_passed)
			linuxTime_list.append(time.time())

		#############################
		## Current point to nextwp ##
		#############################
		elif i == (nextwp-1):
			
			dist_to_next = get_distance(cur_lat, cur_lon, target_lat_list[nextwp-1], target_lon_list[nextwp-1])

			if groundspeed == 0.0:
				vel = wp_speed/100.0
			else:
				vel = groundspeed

			elaspedTime_to_next_in_sec = dist_to_next/vel
			linuxTime_to_next = time.time() + elaspedTime_to_next_in_sec
			human_time_to_next = datetime.fromtimestamp(linuxTime_to_next)
			ETA_next = human_time_to_next.strftime("%H:%M:%S")
			ETA_list.append(ETA_next)
			linuxTime_list.append(linuxTime_to_next)

		##########################
		## Points in the future ##
		##########################
		elif i > (nextwp-1):
			dist_to_next = get_distance(target_lat_list[i-1], target_lon_list[i-1], target_lat_list[i], target_lon_list[i])
			vel = wp_speed/100.0

			elaspedTime_to_next_in_sec = dist_to_next/vel
			linuxTime_to_future = linuxTime_list[i-1] + elaspedTime_to_next_in_sec
			human_time_to_future = datetime.fromtimestamp(linuxTime_to_future)
			ETA_future = human_time_to_future.strftime("%H:%M:%S")
			ETA_list.append(ETA_future)
			linuxTime_list.append(linuxTime_to_future)

		if (round(groundspeed,1) == 0) and (nextwp == total_points):
			ETA_list = ["Passed"]*total_points

	return ETA_list



####################################################
################# Dronekit Listener ################
####################################################

vehicle.add_attribute_listener('location', location_callback)
vehicle.add_attribute_listener('attitude', attitude_callback)
vehicle.add_attribute_listener('gps_0', gps_callback)
vehicle.add_attribute_listener('groundspeed', groundspeed_callback)
vehicle.add_attribute_listener('airspeed', airspeed_callback)
vehicle.add_attribute_listener('mode', mode_callback)
vehicle.add_attribute_listener('battery', batt_callback)
# vehicle.add_attribute_listener('commands', nextwp_callback)
vehicle.parameters.add_attribute_listener("WPNAV_SPEED", wpnav_speed_callback)


#################################################
################# ROS Subscriber ################
#################################################
rospy.Subscriber("/mission", String, mission_callback)


#######################################
################# Loop ################
#######################################
global cmds
cmds = vehicle.commands

global target_lat_list, target_lon_list, total_points
target_lat_list, target_lon_list, total_points = getMission()

rate = rospy.Rate(10)
ETA_list = []

while not rospy.is_shutdown():

	nextwp = cmds.next

	if (mode == "AUTO") and (nextwp != 0):
		ETA_list = calculate_ETA(nextwp, lat, lon)
		print(ETA_list)
	else:
		ETA_list = []

	json_data = json.dumps(telem_dict)

	home = vehicle.home_location
	if home is not None:
		home_lat = home.lat
		home_lon = home.lon

	if (home_lat != 0.0) and (home_lon != 0.0):
		tohome = get_distance(home_lat, home_lon, lat, lon)
		telem_dict["TELEMETRY"]["DIST"]["TOHOME"] = round(tohome, 2)


	print("{:} | next: {:d} | r: {:.2f} | p: {:.2f} | y: {:.2f} | lat: {:.5f} | lon: {:.5f} | altRel: {:.2f} | fix: {:d} | ASPD: {:.2f} | GSPD: {:.2f} | hLat: {:.5f} | hLon: {:.5f} | tohome: {:.2f} | trav: {:.2f} | volt: {:.2f}".format(\
		mode, nextwp, roll, pitch, yaw, lat, lon, alt_rel, fix_type, airspeed, groundspeed, home_lat, home_lon, tohome, travelled, volt))

	file = open(file_path, "w+") 
	file.write(json_data)
	cmd1 = 'echo $(cat console_telemetry.txt) > {:s}'.format(CONSOLE_PORT)
	# subprocess.call(cmd1, shell=True)				# for python2
	# subprocess.run(cmd1, shell=True, check=True)	# for python3


	rate.sleep()